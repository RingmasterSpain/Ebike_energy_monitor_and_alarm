

/*  ==================================================================

  Sketch control 
  Activa un LED RGB según el voltaje y tipo batería (Divisor voltaje)
  Morado sobrecarga, azul 90-100%, verde 50-90%, amarillo del 30 al 40%,
  naranja del 20 al 30%, rojo 10 al 20% y rojo parpadeante por debajo del 10%

  Además, cuando está "dormido" vigila si alguien mueve la vici con el GY-521,
  haciendo sonar la alarma en ese caso
  
  Autor: David Losada, basado en trabajos previos de otros autores:
  Parte de código de la referencia rápida del Digispark: http://digistump.com/wiki/digispark/quickref
    
  Version: 0.7 bajo licencia GPLv3
  Fecha: diciembre 2016

  Includes NeoPixel Ring simple sketch code from (c) 2013 Shae Erisson
  released under the GPLv3 license to match the rest of the AdaFruit NeoPixel library
  
  ==================================================================   */

//#include <EEPROMex.h> //La librería Neopixel ocupa demasiado en el ATtiny; anulo toda la parte de guardado de datos estadísticos
#include <Adafruit_NeoPixel.h> //Para el control del led

//from https://bigdanzblog.wordpress.com/2014/08/10/attiny85-wake-from-sleep-on-pin-state-change-code-example/
#include <avr/sleep.h>   
//Librerías para dormir al procesador y ahorrar energía cuando no hace nada
#include <avr/power.h>
#include <avr/wdt.h>
#include <avr/interrupt.h>  //creo que al final no se usa, pero mejor dejarla (el compilador no la incluye si no se usa, por lo que no ocupa)

//******************* A CAMBIAR SEGÚN TU CONFIGURACIÓN ********************************

//Relación de voltaje y estado de carga de la batería; se puede agregar para cualquier tipo de batería, siempre teniendo en cuenta que estaremos comprobando sólo una celda de hasta 5V
//por lo que es imprescindible utilizar un BMS de equilibrado de celdas en la carga para evitar problemas con las celdas no monitorizadas
//Descomentamos el tipo de batería que queramos utilizar
//(VALORES %: 1%,8%,20%,30%,40%,90%,100%)
const double mVoltCarga[7]={2.8,3.10,3.17,3.198,3.22,3.4,3.6}; //tabla de relación de voltajes y carga de LIFEPO  (recomendado calibrar (más abajo se indica), por la pequeña diferencia entre estados)
//const double mVoltCarga[7]={3,3.2,3.3,3.6,3.65,4.05,4.2}; //tabla de relación de voltajes y carga de LiCo y LiPo
const double ajusteVolt=-0.05; //Voltaje de calibración según el chip

const byte luminLED=150; //De 20 a 255, el valor de luminosidad máxima según el LED (para ahorro de energía y duración del LED recomendado valores <150)

const double refIntVolt=1.088; //Aquí se calibra el valor de ref. int de 1,1V, que puede variar de 1,09 a 1,2V
const byte minutos=15; //Después de estos minutos,si no hay variación de voltaje, desconectamos electrónica (relé y lámpara)

//Definición pines analógicos monitorización batería
//En el ATTiny85 las entradas son (1)=P2; (2)=P4; (3)=P3; (0)=P5 y pines PWM P0, P1 y P4
#define relePIN        3 //Conectar la batería y luces; desconectar cuando la batería baje de 2,8V
#define intPIN         2 //PB2 is INT0 pin; Pin de interruptor para encender Y apagar bici (activar relé), *** HAY QUE CONECTARLO A GND (Tierra) para activarlo
#define ledPIN         13 //Pin del LED incorporado, para hacerlo parpadear, en el ATTiny85 B es el 1
#define zumbPIN        7 //Para activar zumbador intermitentemente cuando la batería baje del 5%
#define voltajePIN     0 //Entrada de voltaje
//Definición LED RGB Neopixel PL-9823-F5/F8 http://surrealitylabs.com/2014/08/playing-with-the-pl9823-f5-a-breadboardable-neopixel-compatible-led/
// Which pin on the Arduino is connected to the NeoPixels?
#define PIN            4 //Salida que usamos para la comunicación digital con el LED RGB
// Número de Neopixels conectados al Arduino
#define NUMPIXELS      1

//***********FIN CONFIGURACIÓN PERSONALIZADA***************************************

//unsigned long millisInicio=0; //Para comprobar paso de horas
//unsigned long millisUso=0; //Tiempo en milisegundos cada vez que comprobamos si se está usando, y si no desconectamos para ahorrar batería
//unsigned long millisVoltaje=0; //Segunda comprobación voltaje
boolean parada=false; //Para doble chequeo de parada
boolean voltIgual=false; //Chequeo se vuelve a cumplir; sería raro que coincidiera dos veces seguidas si no está parada
boolean alarma=false; //Hacer la alarma intermitente
boolean parpadea=false; //Para parpadear rojo
boolean encendido=true; //Controlamos si está desconectada la bici

double voltajeAnt=0; //Guardar voltaje anterior
double voltaje[6]={0,0,0,0,0,0}; //Valores obtenidos muestras
double value=0; //Voltaje obtenido
long contador=0; //Para comprobar el tiempo según el número de veces que se ejecute
//unsigned long timeLED=0; //Almacenar tiempo transcurrido

byte color=0; //Para guardar el color anterior

// When we setup the NeoPixel library, we tell it how many pixels, and which pin to use to send signals.
// Note that for older NeoPixel strips you might need to change the third parameter--see the strandtest
// example for more information on possible values.
Adafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);

void setup()   { 

////Resetea la EEPROM la primera vez que la usamos
//EEPROM.setMemPool(0,512); //Establecemos inicio y tamaño de EEPROM de la tarjeta utilizada
//EEPROM.setMaxAllowedWrites(128); //Mínimo para que pueda hacerse el primer borrado completo
////rellenamos de 0 los datos de EEPROM
////Attiny85 tiene 512 Bytes de EEPROM; ajustar según el que uséis
//if (EEPROM.readLong(508)!=4011983) { //En ese punto, preferiblemente al final, guardo un valor para saber si ya la he reseteado
//  for(int i=0; i<500; i=i+4) { //Ajustar el valor según el tamaño de la (EEPROM)-8
//     EEPROM.update(i,0);
//      }
//  EEPROM.update(508,4011983); //Almacenamos un número indicativo de que ya se ha inicializado en la última posición
//  //Serial.println("Borrado de EEPROM terminado"); //sólo debería aparecer 1 vez
//}

//Líneas de configuración del WatchDog Timer
/*** Setup the WDT ***/
  
  /* Clear the reset flag. */
  MCUSR &= ~(1<<WDRF);
  
  /* In order to change WDE or the prescaler, we need to
   * set WDCE (This will allow updates for 4 clock cycles).
   */
  WDTCSR |= (1<<WDCE) | (1<<WDE);

  /* set new watchdog timeout prescaler value */ 
   //WDP3 - WDP2 - WPD1 - WDP0 - time
  // 0      0      0      0      16 ms
  // 0      0      0      1      32 ms
  // 0      0      1      0      64 ms
  // 0      0      1      1      0.125 s
  // 0      1      0      0      0.25 s
  // 0      1      0      1      0.5 s
  // 0      1      1      0      1.0 s
  // 0      1      1      1      2.0 s
  // 1      0      0      0      4.0 s
  // 1      0      0      1      8.0 s

  WDTCSR = 1<<WDP2 | 1<<WDP1; /* 1.0 seconds */
  //WDTCSR = 1<<WDP2 | 1<<WDP1 | 1<<WDP0; /* 2.0 seconds */
  //WDTCSR = 1<<WDP3; /* 4.0 seconds */
  //WDTCSR = 1<<WDP0 | 1<<WDP3; /* 8.0 seconds */
  
  /* Enable the WD interrupt (note no reset). */
  WDTCSR |= _BV(WDIE);

//Definir pines
//You need not set pin mode for analogRead - though if you have set the pin to
//output and later want to read from it then you need to set pinMode(0,INPUT);
//where 0 is the physical pin number not the analog input number.
//pinMode(PIN, OUTPUT);
pinMode(relePIN,OUTPUT);
pinMode(ledPIN,OUTPUT);
pinMode(zumbPIN,OUTPUT);
pinMode(voltajePIN,INPUT);
//Pin para reactivar el motor (OPCIONAL) (tendríamos que conectarlo a tierra para activarlo)
pinMode(intPIN,INPUT);
digitalWrite(intPIN, HIGH); //Ponemos el pin en HIGH mediante su resistencia interna (pullup), evitando interferencias

digitalWrite(relePIN,HIGH); //Encendemos la bici al conectarlo

pixels.begin(); // This initializes the NeoPixel library.
//Encendemos los LEDs para indicar puesta en marcha y comprobar que los colores funcionan
//Eliminar esto si necesitamos más memoria para el programa
  // pixels.Color convierte valores RGB, de 0,0,0 hasta 255,255,255; (verde, rojo, azul)
  pixels.setPixelColor(0, pixels.Color(0,150,0)); //Encendemos rojo
  pixels.show(); // Envía el color actualizado al hardware. 
  delay(200);
  pixels.setPixelColor(0, pixels.Color(150,0,0));
  pixels.show(); //Verde
  delay(200);
  pixels.setPixelColor(0, pixels.Color(0,0,150));
  pixels.show(); //Azul
  delay(200);
  for(int x=0; x<1; x++) { //Hacemos parpadear todos dos veces
  pixels.setPixelColor(0, pixels.Color(100,100,100)); //Blanco
  pixels.show();
  delay(300);
  pixels.setPixelColor(0, pixels.Color(0,0,0)); //apagado
  pixels.show(); 
  delay(300);
  }
//millisInicio=millis();

Serial.begin(9600);
Serial.println("Iniciamos programa");

}

void loop() {

value=doubleMap(analogRead(voltajePIN),0,1023,0,5)+ajusteVolt; //Cogemos un valor inicial del voltaje

//Para velocidad de respuesta; si se detecta activación manual del interruptor, apagamos LED indicador y desconectamos relé
//El resto del código se ejecutará 1 vez cada 1 segundos.
//for(int x=1; x<5; x++) {
  if (digitalRead(intPIN)==LOW and (encendido==true)) {
    apagaTodo();
//    break;
  } 
  else if (digitalRead(intPIN)==LOW and (encendido==false)) {
    enciendeTodo();
//    break;
  }
//  delay(50); 
//}

if (encendido==true) {

contador++;
//Recoge 6 muestras para sacar medias
Serial.println("Leemos valores");
for(int x=0; x<6; x++) {    
  //coge el voltaje en milivoltios, pasamos a voltios con la rutina doubleMap ahorrando memoria
  voltaje[x] = doubleMap(analogRead(voltajePIN),0,1023,0,5); //Pasamos los valores de entre 0 a 1023 a valores entre 0 y 5V
  delay(15); // espera entre lecturas
}
//Ordenamos para descartar bajo y alto
for(int x=0; x<6; x++) {    
  for(int y=0; y<6; y++) {    
    if (voltaje[y]<voltaje[y+1]) {
      value=voltaje[y];
      voltaje[y]=voltaje[y+1];
      voltaje[y+1]=value;
    }
  }
}

//Sacar media y voltaje real
value=0;
for(int x=1; x<5; x++) {    
  value=value+voltaje[x];
}
value=(double)value/4;
value= int(value*100); //Trabajamos con sólo dos decimales (no merece la pena más exactitud)
value= value/100;
value=value+ajusteVolt;

Serial.print("Voltaje=");
Serial.println(value);
delay(100);

//Aquí se evalúa el color del led según los valores del voltaje, para evitar que fluctúe se tiene en cuenta
//qué color tenía antes, y no cambia hasta que haya una variación mayor de 0,02V
if (value<=mVoltCarga[1]) { //ROJO PARPADEANTE, SE DAÑA LA BATERÍA; RECARGAR LO ANTES POSIBLE
      color=0;
      if (parpadea==false) {
        pixels.setPixelColor(0, pixels.Color(0,luminLED,0));
        parpadea=true;
      }
      else { pixels.setPixelColor(0, pixels.Color(0,0,0)); //apagado
      parpadea=false;
      }
}
else if (value<=mVoltCarga[2] && value>mVoltCarga[1]) { //ROJO; Recargar lo antes posible
      //Si el color no estaba establecido o era el mismo o ha variado suficientemente el voltaje
      if (color==0  or color==1 or (color==2 and value<=mVoltCarga[2]-0.02)) { 
        color=1;
        pixels.setPixelColor(0, pixels.Color(0,luminLED,0));
      }
}      
else if (value<=mVoltCarga[3] && value>mVoltCarga[2]) { //NARANJA; se parece más al rojo
      if (color==0  or color==2 or (color==3 and value<=mVoltCarga[3]-0.02) or (color==1 and value>mVoltCarga[2]+0.02) ) { 
        color=2;
        pixels.setPixelColor(0, pixels.Color(luminLED*0.3,luminLED*0.7,luminLED*0.1)); //Entre el 20 y el 30%; momento de recargar la batería
      }
}
else if (value<=mVoltCarga[4] && value>mVoltCarga[3]) { //AMARILLO color 3
      if (color==0  or color==3 or (color==4 and value<=mVoltCarga[4]-0.02) or (color==2 and value>mVoltCarga[3]+0.02) ) { 
        color=3;
        pixels.setPixelColor(0, pixels.Color(luminLED*0.4,luminLED*0.5,0)); //Aconsejable recargar batería
      }
}
else if (value<=mVoltCarga[5] && value>mVoltCarga[4]) {//VERDE color 4
      if (color==0  or color==4 or (color==5 and value<=mVoltCarga[5]-0.02) or (color==3 and value>mVoltCarga[4]+0.02) ) { 
        color=4;
        pixels.setPixelColor(0, pixels.Color(luminLED*0.5,0,0)); //Le bajo la intensidad todavía más; al fin y al cabo, siempre estará encendido
      }
}
else if (value<=mVoltCarga[6] && value>mVoltCarga[5]) {//AZUL color 5
      if (color==0 or color==5 or (color==6 and value<=mVoltCarga[6]-0.02) or (color==4 and value>mVoltCarga[5]+0.02) ) { 
        color=5;
        pixels.setPixelColor(0, pixels.Color(0,0,luminLED)); //Se ha sobrecargado; recomendable no llegar al azul para maximizar vida útil  
      }
}
else  { //>100% VIOLETA 6
      color=6;
      pixels.setPixelColor(0, pixels.Color(0,luminLED*0.6,luminLED*0.75)); //Por encima de lo recomendado; PELIGROSO
}
pixels.show(); //Actualizamos el color del led

//DEBUG
//Serial.print("Contador=");
//Serial.println(contador);
//Serial.print("VoltajeAnt=");
//Serial.println(voltajeAnt);

//Si detectamos que la bici no se usa durante el tiempo indicado, apagamos todo, hasta que no se pulse en interruptor del P2 no vuelve a continuar
if (contador>(minutos*30)) { //Al hacer tres comprobaciones dentro del tiempo marcado, nos aseguramos
  if (parada==false) {
    parada=true;
    voltajeAnt=value; //Para redondear a 3 dígitos (sólo nos interesa comparar con dos decimales)
  }
  else if (contador>(minutos*60)){ //Si han pasado 5 min. más y el voltaje sigue igual
    parada=false;
    if (value>=voltajeAnt-0.01 and value<=voltajeAnt+0.01) {
      voltIgual=true;
    }
  }
}

if (voltIgual==true) { //Desconectamos relé y LED al cumplirse que no hay uso
    contador=0; //reseteamos tiempo
    voltIgual=false;
    if (voltajeAnt==value) {
      //En dos chequeos durante el tiempo no ha cambiado voltaje, por lo que dormimos la cpu
      apagaTodo();
    }
}

//si baja del valor de 1% hacemos sonar alarma brevemente y apagamos todo
//if (value<=mVoltCarga[0]) {
//  digitalWrite(relePIN,LOW);
//  for(int x=1; x<20; x++) {  
//    digitalWrite(zumbPIN,HIGH);
//    delay(100);
//    digitalWrite(zumbPIN, LOW); //Desactivamos alarma por si quedaba activada
//    delay(100);
//  }
//  apagaTodo();
//}
} //**** FIN COMPROBACIÓN
else if (value<mVoltCarga[2]); { //si la batería baja demasiado, avisamos
      if (parpadea==false) {
        pixels.setPixelColor(0, pixels.Color(0,luminLED,0));
        parpadea=true;
      }
      else { pixels.setPixelColor(0, pixels.Color(0,0,0)); //apagado
      parpadea=false;
      }
}

//Para protección de batería
//Si baja del 4,5% la batería, activamos zumbador hasta que sea del 1% o menor
if (value<=(mVoltCarga[0]+mVoltCarga[1])/2 && value>=mVoltCarga[0]) {
  if (alarma==false) {
    alarma=true;
    digitalWrite(zumbPIN,HIGH);
  }
  else {
  alarma=false;
  digitalWrite(zumbPIN, LOW);
  }
}
//Utilizo la EEPROM para valores estadísticos únicamente; se puede eliminar si se considera
/* DATOS GUARDADOS EN EEPROM *PENDIENTE DE HACER
 *  0: Horas funcionamiento Arduino
 *  3: Último voltaje Arduino, para controlar el número de recargas
 *  7: Contador de recargas de baterías
 *  11: Contador de viajes/encendidos
 *  15: Voltaje máximo histórico
 *  19: Voltaje mínimo histórico
 *  23: 
 *  27: 
 *  31: 

*/

////Guardamos las horas de uso en la EEPROM
//if ((millis()-millisInicio)>3600000) { //Ha pasado una hora
//  millisInicio=millis(); 
//  EEPROM.update(0,EEPROM.readLong(0)+1); //Añadimos una hora al contador
//  } 
////Comprobamos valor mínimo y actualizamos
//if (EEPROM.readLong(19)>value)  {
//  EEPROM.update(19,value);
//}
////Comprobamos valor máximo y actualizamos
//if (EEPROM.readLong(15)<value) {
//  EEPROM.update(15,value);
//}

  //Hacemos parpadear al LED
//  if (digitalRead(ledPIN)==HIGH) {
//    digitalWrite(ledPIN,LOW);
//  }
//  else {
//      digitalWrite(ledPIN,HIGH); //enciende LED suavemente
//  }

//delay(100); //para dar tiempo al serial
enterSleep();
//THEEND 
}

void apagaTodo() { //Aquí desconectamos todo para ahorrar energía
      //Prefiero conectar el interruptor entre el PIN y Tierra, con una resistencia que mantenga el pin en HIGH de 10K
      //Ya que por ejemplo en el P3, hay una resistencia pull-up y la resistencia externa podría no ser suficiente para ponerlo en LOW
      //pero si lo conectamos a Tierra, no habrá duda de que lo ponemos en LOW.
      //Hay que tener en cuenta que sólo dormimos la cpu, pero todos los pines quedan con las salidas preestablecidas
        digitalWrite(relePIN,LOW); //apagamos todo y ponemos al attiny a dormir
        pixels.setPixelColor(0, pixels.Color(0,0,0)); //Apagamos LED, ya que es independiente; sigue gastando algo, pero menos
        pixels.show(); //Actualizamos
        encendido=false;
        delay(400); //Damos tiempo a soltar el interruptor
}

void enciendeTodo() { //Aquí conectamos todo lo que nos interese
      //Prefiero conectar el interruptor entre el PIN y Tierra, con una resistencia que mantenga el pin en HIGH de 10K
      //Ya que por ejemplo en el P3, hay una resistencia pull-up y la resistencia externa podría no ser suficiente para ponerlo en LOW
      //pero si lo conectamos a Tierra, no habrá duda de que lo ponemos en LOW.
      //Hay que tener en cuenta que sólo dormimos la cpu, pero todos los pines quedan con las salidas preestablecidas
        digitalWrite(relePIN,HIGH); //apagamos todo y ponemos al attiny a dormir
        encendido=true;
        contador=0;
        delay(400); //Damos tiempo a soltar el interruptor
}


// *************** RUTINAS LECTURA VOLTAJE ***************
double doubleMap(double x, double in_min, double in_max, double out_min, double out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}


//RUTINAS
//Code from http://donalmorrissey.blogspot.com.es/2010/04/sleeping-arduino-part-5-wake-up-via.html
/***************************************************
 *  Name:        ISR(WDT_vect)
 *
 *  Returns:     Nothing.
 *
 *  Parameters:  None.
 *
 *  Description: Watchdog Interrupt Service. This
 *               is executed when watchdog timed out.
 *
 ***************************************************/
ISR(WDT_vect)
{
 //Aquí el código que queremos se ejecute cuando el watchdog "despierta" al procesador

}



/***************************************************
 *  Name:        enterSleep
 *
 *  Returns:     Nothing.
 *
 *  Parameters:  None.
 *
 *  Description: Enters the arduino into sleep mode.
 *
 ***************************************************/
void enterSleep(void)
{
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);   /* EDIT: could also use SLEEP_MODE_PWR_SAVE for less power consumption. */
  sleep_enable();
  
  /* Now enter sleep mode. */
  sleep_mode();
  
  /* The program will continue from here after the WDT timeout*/
  sleep_disable(); /* First thing to do is disable sleep. */
  
  /* Re-enable the peripherals. */
  power_all_enable();
}

